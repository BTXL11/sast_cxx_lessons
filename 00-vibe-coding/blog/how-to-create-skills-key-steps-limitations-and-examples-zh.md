# 如何创建技能：关键步骤、限制与示例

*学习如何编写定制化技能，让 Claude 输出更强、更有效的结果。*

- **类别**：编程、智能体（Agents）  
- **产品**：Claude 应用  
- **日期**：2025 年 11 月 19 日  
- **阅读时间**：5 分钟

-----

**技能（Skills）是用于扩展 Claude 在特定任务或领域中能力的自定义指令。** 当你通过 `SKILL.md` 文件创建技能时，你实际上是在教 Claude 更高效地处理特定场景。技能的强大之处在于，它们能够编码机构知识、标准化输出，并处理复杂的多步骤工作流——而这些工作流若不使用技能，往往需要反复说明，或投入大量资源构建专用智能体。

在此之前，诸如AugmentCode等编程工具已经推出可以手动触发的快捷指令，和这个有很相似的用处，是一种对系统提示词的扩展。

你可以通过我们的**技能创建模板**或手动方式，将 Claude 从通用助手转变为专精于你特定工作流的专家。（小贴士：为简化流程，建议使用该模板构建你的 `SKILL.md` 文件，并在此基础上进行定制。）

## 分五步创建技能

遵循这一结构化方法，构建触发更可靠的技能。

### 1. 理解核心需求

在动笔之前，先明确你的技能要解决什么问题。优秀的技能应针对具体需求，并有可衡量的结果。“从 PDF 中提取财务数据并格式化为 CSV”优于“帮我处理财务事务”，因为它明确了输入格式、操作内容和预期输出。

自问以下问题：

- 该技能具体完成什么任务？
- 什么触发条件应激活它？
- 成功的标准是什么？
- 存在哪些边缘情况或限制？

### 2. 编写名称

技能需包含三个核心组件：**名称**（清晰标识符）、**描述**（何时激活）、**指令**（如何执行）。实际上，在 `SKILL.md` 文件中，只有**名称**和**描述**会影响触发机制——即 Claude 是否会因需要特定知识或工作流而调用该技能。

名称应简洁明了。使用小写字母加连字符（例如：`pdf-editor`、`brand-guidelines`）。保持简短清晰。

### 3. 编写描述字段

描述决定技能何时被激活，因此是最关键的组件。请从 Claude 的视角撰写，聚焦于触发条件、能力范围和使用场景。

一个优秀的描述需平衡以下要素：具体能力、清晰触发点、相关上下文和边界限制。

> **弱描述**：  
> 此技能用于处理 PDF 和文档。

> **强描述**：  
> 全面的 PDF 操作工具包，支持提取文本与表格、创建新 PDF、合并/拆分文档、处理表单等。当 Claude 需要填写 PDF 表单，或以编程方式批量处理、生成、分析 PDF 文档时使用。适用于文档工作流与批量操作。**不适用于**简单的 PDF 查看或基础格式转换。

强描述版本为 Claude 提供了多个判断依据：具体动词（提取、创建、合并）、明确用例（表单填写、批量操作）以及清晰边界（不用于简单查看）。

### 4. 编写主指令

指令应结构清晰、易于浏览、可执行。使用 Markdown 标题、项目符号列举选项，用代码块展示示例。

采用清晰的层级结构：概述、前提条件、执行步骤、示例、错误处理和限制。将复杂工作流拆分为多个阶段，每个阶段明确输入与输出。

包含展示正确用法的具体示例。明确说明技能**不能做什么**，以防止误用并管理预期。你的 `SKILL.md` 文件还可包含附加参考文件和资源，为智能体在技能触发时提供更清晰的指导。

### 5. 上传你的技能

根据你使用的 Claude 平台，按以下方式上传技能：

- **Claude.ai（Claude 应用）**：进入**设置**，在其中添加自定义技能。自定义技能需 Pro、Max、Team 或 Enterprise 计划，并启用代码执行功能。此处上传的技能为**用户个人专属**，不会在组织内共享，也无法由管理员集中管理。
- **Claude Code**：在插件或项目根目录下创建 `skills/` 目录，并在其中添加包含 `SKILL.md` 文件的技能文件夹。安装插件后，Claude 会自动发现并使用这些技能。示例结构：

  ```text
  my-project/
  ├── skills/
  │   └── my-skill/
  │       └── SKILL.md
  ```

- **Claude 开发者平台**：通过 Skills API（`/v1/skills` 端点）上传技能。使用带 Beta 标头的 POST 请求：

  ```bash
  curl -X POST "https://api.anthropic.com/v1/skills" \
    -H "x-api-key: $ANTHROPIC_API_KEY" \
    -H "anthropic-version: 2023-06-01" \
    -H "anthropic-beta: skills-2025-10-02" \
    -F "display_title=My Skill Name" \
    -F "files[]=@my-skill/SKILL.md;filename=my-skill/SKILL.md"
  ```

-----

## 4. 测试与验证

在部署前，用真实场景测试你的技能。系统化测试能揭示指令中的漏洞、描述中的模糊点，以及仅在实际使用中才会出现的意外边缘情况。

构建一个覆盖三类场景的测试矩阵：

1. **常规操作**：用技能应完美处理的典型请求进行测试。例如，若你构建了财务分析技能，可尝试“分析微软最新财报”或“为此份 10-K 文件构建数据包”。这些基线测试可确认指令按预期工作。
2. **边缘情况**：用不完整或异常的输入进行测试。当数据缺失、文件格式意外、用户指令模糊时会发生什么？技能应优雅处理——要么产出降级但仍可用的结果，要么说明需要哪些信息才能继续。
3. **范围外请求**：用看似相关但不应触发该技能的任务进行测试。例如，若你构建了 NDA 审查技能，可尝试“审查这份雇佣协议”或“分析这份租赁合同”。此时技能应保持静默，由其他技能或通用 Claude 能力处理请求。

为更深入验证，可考虑实施以下测试：

- **触发测试**：技能是否在预期时激活？测试显式请求（如“使用财务数据包技能分析这家公司”）和自然请求（如“帮我理解这家公司的财务状况”）。技能是否在无关时保持不激活？一个范围明确的技能应懂得何时不介入。测试相似但不同的请求以验证边界。
- **功能测试**：包括输出一致性（类似输入的多次运行是否产生可比结果？）、可用性（不熟悉该领域的人能否成功使用？）和文档准确性（你的示例是否与实际行为一致？）。

## 5. 基于使用情况迭代

监控技能在真实使用中的表现。若触发不稳定，优化描述；若输出不一致，澄清指令。与提示工程一样，最佳技能通过实践不断演进。

-----

## 创建技能的通用最佳实践

这些原则有助于你创建可维护、可复用且真正有用的技能，而非纸上谈兵。

### 从用例出发

不要凭空编写技能。在你有真实且重复的任务时再构建。最佳技能解决你经常遇到的问题。  
创建技能前自问：我是否已执行该任务至少五次？未来是否还会执行至少十次？若是，则值得构建技能。

### 定义成功标准——并将其写入技能

告诉 Claude 什么是良好的输出。若你创建财务报告，需明确所需章节、格式标准、验证检查和质量阈值。将这些标准写入指令，使 Claude 能自我校验。

### 使用“技能创建者”技能

**技能创建者（skill-creator）技能**可引导你构建结构良好的技能。它会提出澄清性问题、建议描述改进，并帮助正确格式化指令。该技能可在 **GitHub 技能仓库** 和 **Claude.ai** 上直接使用，尤其适合前几个技能的创建。

-----

## 技能的限制与注意事项

理解技能的工作机制及其边界，有助于你设计更高效的技能并设定合理预期。

- **技能触发机制**：Claude 会将技能描述与用户请求进行语义匹配以判断相关性。这**不是关键词匹配**——Claude 理解语义关联。然而，模糊的描述会降低触发准确性。
- **多个技能可同时激活**，只要它们处理复杂任务的不同方面。描述过于宽泛会导致不当激活，而遗漏用例则会导致激活失败。
- **合适的文件大小**：编写技能时，避免用不必要内容占用上下文窗口。考虑每条信息是否需在每次调用时加载，还是可按需加载。

采用“菜单式”方法：若技能涵盖多个独立流程或选项，`SKILL.md` 应描述可用内容，并通过相对路径引用各独立文件。Claude 仅读取与用户任务相关的文件，其余文件在该对话中保持未加载状态。

这些独立文件无需互斥。关键原则是将内容拆分为合理片段，并让 Claude 根据任务选择所需部分。

-----

## 真实技能示例

### 技能示例 #1：docx 创建技能

````markdown
---
name: docx
description: "全面的文档创建、编辑与分析功能，支持修订跟踪、批注、格式保留和文本提取。当 Claude 需要处理专业文档（.docx 文件）时使用，包括：(1) 创建新文档，(2) 修改或编辑内容，(3) 处理修订，(4) 添加批注，或任何其他文档任务"
license: 专有。完整条款见 LICENSE.txt
---

# DOCX 创建、编辑与分析

## 概述
用户可能要求你创建、编辑或分析 .docx 文件的内容。.docx 文件本质上是一个包含 XML 文件和其他资源的 ZIP 归档，你可以读取或编辑。针对不同任务，你有不同的工具和工作流可用。

## 工作流决策树

### 读取/分析内容
使用下方“文本提取”或“原始 XML 访问”部分

### 创建新文档
使用“创建新 Word 文档”工作流

### 编辑现有文档
- **你自己创建的文档 + 简单修改**：使用“基础 OOXML 编辑”工作流
- **他人创建的文档**：使用**“修订工作流”**（推荐默认）
- **法律、学术、商业或政府文档**：必须使用**“修订工作流”**

## 读取与分析内容

### 文本提取
若只需读取文档的文本内容，应使用 pandoc 将文档转换为 Markdown。Pandoc 能出色保留文档结构，并可显示修订内容：

```bash
# 转换文档为 Markdown 并保留所有修订
pandoc --track-changes=all path-to-file.docx -o output.md
# 选项: --track-changes=accept/reject/all
```

### 原始 XML 访问

当你需要访问批注、复杂格式、文档结构、嵌入媒体或元数据时，需使用原始 XML 访问。对于这些功能，你需要解包文档并读取其原始 XML 内容。

#### 解包文件

`python ooxml/scripts/unpack.py <office_file> <output_directory>`

#### 关键文件结构

- `word/document.xml` - 主文档内容
- `word/comments.xml` - 文档中引用的批注
- `word/media/` - 嵌入的图像和媒体文件
- 修订使用 `<w:ins>`（插入）和 `<w:del>`（删除）标签

## 创建新 Word 文档

从头创建 Word 文档时，使用 **docx-js**，它允许你使用 JavaScript/TypeScript 创建 Word 文档。

### 工作流

1. **必须完整阅读文件**：完整阅读 [`docx-js.md`](https://www.google.com/search?q=docx-js.md)（约 500 行），从头到尾。**切勿设置范围限制**。在继续创建文档前，必须通读全文以掌握详细语法、关键格式规则和最佳实践。
2. 使用 Document、Paragraph、TextRun 组件创建 JavaScript/TypeScript 文件（可假设所有依赖已安装，否则参见下方依赖部分）
3. 使用 Packer.toBuffer() 导出为 .docx

## 编辑现有 Word 文档

编辑现有 Word 文档时，使用 **Document 库**（一个用于 OOXML 操纵的 Python 库）。该库自动处理基础设施设置，并提供文档操纵方法。对于复杂场景，你可通过该库直接访问底层 DOM。

### 工作流

1. **必须完整阅读文件**：完整阅读 [`ooxml.md`](https://www.google.com/search?q=ooxml.md)（约 600 行），从头到尾。**切勿设置范围限制**。通读全文以掌握 Document 库 API 和直接编辑文档文件的 XML 模式。
2. 解包文档：`python ooxml/scripts/unpack.py <office_file> <output_directory>`
3. 使用 Document 库创建并运行 Python 脚本（参见 https://www.google.com/search?q=ooxml.md 的“Document 库”部分）
4. 打包最终文档：`python ooxml/scripts/pack.py <input_directory> <office_file>`

Document 库既提供常用操作的高层方法，也支持复杂场景的直接 DOM 访问。

## 文档审阅的修订工作流

此工作流允许你先用 Markdown 规划完整的修订，再在 OOXML 中实现。**关键**：为实现完整修订，必须系统性地实施**所有**更改。

**批处理策略**：将相关更改分组为每批 3–10 项。这使调试可控，同时保持效率。在进入下一批前测试当前批。

**原则：最小、精准编辑**  
实施修订时，仅标记实际变更的文本。重复未变更文本会使编辑更难审阅，显得不专业。将替换拆分为：[未变更文本] + [删除] + [插入] + [未变更文本]。通过从原文提取 `<w:r>` 元素并复用，为未变更文本保留原始 RSID。

示例——将句子中的“30 天”改为“60 天”：

```python
# 错误 - 替换整个句子
'<w:del><w:r><w:delText>The term is 30 days.</w:delText></w:r></w:del><w:ins><w:r><w:t>The term is 60 days.</w:t></w:r></w:ins>'

# 正确 - 仅标记变更部分，为未变更文本保留原始 <w:r>
'<w:r w:rsidR="00AB12CD"><w:t>The term is </w:t></w:r><w:del><w:r><w:delText>30</w:delText></w:r></w:del><w:ins><w:r><w:t>60</w:t></w:r></w:ins><w:r w:rsidR="00AB12CD"><w:t> days.</w:t></w:r>'
```

### 修订工作流

1. **获取 Markdown 表示**：将文档转换为保留修订的 Markdown：

    ```bash
    pandoc --track-changes=all path-to-file.docx -o current.md
    ```

2. **识别并分组更改**：审阅文档，识别**所有**需要的更改，并按逻辑分组：
   **定位方法**（用于在 XML 中查找更改）：

     - 章节/标题编号（如“第 3.2 节”、“第四条”）
     - 若有编号，使用段落标识符
     - 带唯一上下文的 grep 模式
     - 文档结构（如“第一段”、“签名区块”）
     - **切勿使用 Markdown 行号**——它们无法映射到 XML 结构

   **分组策略**（每批 3–10 项相关更改）：

     - 按章节：“第 1 批：第 2 节修订”、“第 2 批：第 5 节更新”
     - 按类型：“第 1 批：日期修正”、“第 2 批：缔约方名称变更”
     - 按复杂度：先处理简单文本替换，再处理复杂结构变更
     - 按顺序：“第 1 批：第 1–3 页”、“第 2 批：第 4–6 页”

3. **阅读文档并解包**：

     - **必须完整阅读文件**：完整阅读 [`ooxml.md`](https://www.google.com/search?q=ooxml.md)（约 600 行），从头到尾。**切勿设置范围限制**。特别关注“Document 库”和“修订模式”部分。
     - **解包文档**：`python ooxml/scripts/unpack.py <file.docx> <dir>`
     - **记录建议的 RSID**：解包脚本将建议一个用于修订的 RSID。复制此 RSID 供第 4b 步使用。

4. **分批实施更改**：按逻辑分组（按章节、类型或位置）将更改分批，并在单个脚本中实施。此方法：

     - 使调试更简单（批次越小，越易隔离错误）
     - 允许增量进展
     - 保持效率（每批 3–10 项效果良好）

   **建议的分组方式**：

     - 按文档章节（如“第 3 节更改”、“定义”、“终止条款”）
     - 按更改类型（如“日期更改”、“缔约方名称更新”、“法律术语替换”）
     - 按位置（如“第 1–3 页更改”、“文档前半部分更改”）

   对每批相关更改：  
   **a. 将文本映射到 XML**：在 `word/document.xml` 中 grep 文本，验证文本如何在 `<w:r>` 元素间分割。  
   **b. 创建并运行脚本**：使用 `get_node` 查找节点，实施更改，然后 `doc.save()`。参见 https://www.google.com/search?q=ooxml.md 的“Document 库”部分获取模式。  
   **注意**：在编写脚本前，立即 grep `word/document.xml` 以获取当前行号并验证文本内容。每次脚本运行后行号都会变化。

5. **打包文档**：所有批次完成后，将解包目录转换回 .docx：

    ```bash
    python ooxml/scripts/pack.py unpacked reviewed-document.docx
    ```

6. **最终验证**：对完整文档进行综合检查：

     - 将最终文档转换为 Markdown：
       ```bash
       pandoc --track-changes=all reviewed-document.docx -o verification.md
       ```
     - 验证**所有**更改均已正确应用：
       ```bash
       grep "original phrase" verification.md  # 应找不到
       grep "replacement phrase" verification.md  # 应能找到
       ```
     - 检查是否引入了意外更改

## 将文档转换为图像

为直观分析 Word 文档，使用两步流程将其转换为图像：

1. **将 DOCX 转换为 PDF**：
    ```bash
    soffice --headless --convert-to pdf document.docx
    ```
2. **将 PDF 页面转换为 JPEG 图像**：
    ```bash
    pdftoppm -jpeg -r 150 document.pdf page
    ```
    此操作将生成如 `page-1.jpg`、`page-2.jpg` 等文件。

选项：

- `-r 150`：设置分辨率为 150 DPI（可根据质量/大小平衡调整）
- `-jpeg`：输出 JPEG 格式（如需 PNG，使用 `-png`）
- `-f N`：起始页（如 `-f 2` 从第 2 页开始）
- `-l N`：结束页（如 `-l 5` 到第 5 页结束）
- `page`：输出文件前缀

特定范围示例：

```bash
pdftoppm -jpeg -r 150 -f 2 -l 5 document.pdf page  # 仅转换第 2–5 页
```

## 代码风格指南

**重要**：生成 DOCX 操作代码时：

- 编写简洁代码
- 避免冗长的变量名和冗余操作
- 避免不必要的打印语句

## 依赖项

所需依赖（若未安装则安装）：

- **pandoc**：`sudo apt-get install pandoc`（用于文本提取）
- **docx**：`npm install -g docx`（用于创建新文档）
- **LibreOffice**：`sudo apt-get install libreoffice`（用于 PDF 转换）
- **Poppler**：`sudo apt-get install poppler-utils`（用于 pdftoppm 将 PDF 转图像）
- **defusedxml**：`pip install defusedxml`（用于安全 XML 解析）
````

**优势所在**：提供清晰的决策树，根据任务类型引导 Claude 选择正确工作流；采用渐进式披露策略，保持主文件精简，仅在需要时引用详细实现文件；包含具体的好/坏示例，明确展示如何实现修订等复杂模式。

### 技能示例 #2：品牌指南

```markdown
#name: brand-guidelines
description: 将 Anthropic 官方品牌颜色和排版应用于任何可能受益于 Anthropic 视觉风格的产物。当涉及品牌颜色、风格指南、视觉格式或公司设计标准时使用。
license: 完整条款见 LICENSE.txt
---
# Anthropic 品牌样式

## 概述
要访问 Anthropic 官方品牌标识和样式资源，请使用此技能。

**关键词**：品牌、企业形象、视觉识别、后处理、样式、品牌颜色、排版、Anthropic 品牌、视觉格式、视觉设计

## 品牌指南

### 颜色
**主色**：
- 深色：`#141413` - 主文本和深色背景
- 浅色：`#faf9f5` - 浅色背景和深色上的文本
- 中灰：`#b0aea5` - 次要元素
- 浅灰：`#e8e6dc` - 微妙背景

**强调色**：
- 橙色：`#d97757` - 主强调色
- 蓝色：`#6a9bcc` - 次强调色
- 绿色：`#788c5d` - 第三强调色

### 排版
- **标题**：Poppins（Arial 为后备）
- **正文**：Lora（Georgia 为后备）
- **注意**：为获得最佳效果，字体应预先安装在环境中

## 功能

### 智能字体应用
- 对标题（24pt 及以上）应用 Poppins 字体
- 对正文应用 Lora 字体
- 若自定义字体不可用，自动回退到 Arial/Georgia
- 在所有系统上保持可读性

### 文本样式
- 标题（24pt+）：Poppins 字体
- 正文：Lora 字体
- 根据背景智能选择颜色
- 保持文本层级和格式

### 形状与强调色
- 非文本形状使用强调色
- 在橙、蓝、绿强调色间循环
- 在保持品牌调性的同时维持视觉趣味性

## 技术细节

### 字体管理
- 在可用时使用系统安装的 Poppins 和 Lora 字体
- 提供自动回退：标题用 Arial，正文用 Georgia
- 无需安装字体——可使用现有系统字体
- 为获得最佳效果，建议在环境中预先安装 Poppins 和 Lora 字体

### 颜色应用
- 使用 RGB 颜色值实现精确品牌匹配
- 通过 python-pptx 的 RGBColor 类应用
- 在不同系统上保持颜色保真度
```

**优势所在**：提供 Claude 本身不具备的精确、可操作信息（确切的十六进制代码、字体名称、字号阈值），并通过清晰描述告知 Claude 技能的功能和触发时机。

### 技能示例 #3：前端设计技能

```markdown
name: frontend-design
description: 创建独特、生产级的前端界面，具备高设计品质。当用户要求构建 Web 组件、页面或应用程序时使用此技能。生成富有创意、精致的代码，避免通用的 AI 审美。
license: 完整条款见 LICENSE.txt
---

此技能指导创建独特、生产级的前端界面，避免通用的“AI 俗套”审美。实现真实可用的代码，对美学细节和创意选择给予极致关注。

用户提供前端需求：需构建的组件、页面、应用程序或界面。可能包含关于用途、受众或技术约束的上下文。

## 设计思维
编码前，先理解上下文并确定一个**大胆的美学方向**：
- **目的**：此界面解决什么问题？谁使用它？
- **基调**：选择一个极端风格：极简粗暴、混乱极繁、复古未来、自然有机、奢华精致、趣味玩具感、杂志编辑风、粗野原始、装饰艺术/几何、柔和粉彩、工业实用等。风格选择丰富多样。以此为灵感，但设计出真正符合美学方向的作品。
- **约束**：技术要求（框架、性能、无障碍性）。
- **差异化**：什么让它**难以忘怀**？人们会记住的**唯一亮点**是什么？

**关键**：选择清晰的概念方向并精准执行。大胆的极繁主义和精致的极简主义都有效——关键是意图明确，而非强度大小。

然后实现可用代码（HTML/CSS/JS、React、Vue 等），代码需：
- 生产级且功能完整
- 视觉震撼且令人难忘
- 具有清晰一致的美学观点
- 每个细节都精雕细琢

## 前端美学指南
聚焦于：
- **排版**：选择美丽、独特、有趣的字体。避免 Arial 和 Inter 等通用字体；选择能提升前端美学的独特字体；使用意想不到、富有个性的字体组合。将独特的展示字体与精致的正文字体配对。
- **色彩与主题**：坚持一致的美学。使用 CSS 变量确保一致性。主导色搭配鲜明强调色的效果优于含蓄、均匀分布的调色板。
- **动效**：为效果和微交互使用动画。HTML 优先使用纯 CSS 方案。React 环境在可用时使用 Motion 库。聚焦高影响力时刻：一个精心编排的页面加载动效（带 staggered reveals，即 animation-delay）比零散的微交互更能带来愉悦感。使用滚动触发和令人惊喜的悬停状态。
- **空间构成**：非传统布局。不对称。重叠。对角线流动。打破网格的元素。充裕的负空间 **或** 受控的密集排版。
- **背景与视觉细节**：营造氛围和深度，而非默认使用纯色。添加符合整体美学的上下文效果和纹理。应用创意形式，如渐变网格、噪点纹理、几何图案、分层透明、戏剧性阴影、装饰边框、自定义光标和颗粒叠加。

**切勿使用**通用的 AI 生成审美，如过度使用的字体家族（Inter、Roboto、Arial、系统字体）、陈词滥调的配色方案（尤其是白底紫渐变）、可预测的布局和组件模式，以及缺乏上下文特性的千篇一律设计。

创意解读，做出符合上下文的意外选择。每个设计都应独一无二。在明暗主题、不同字体、不同美学间变化。**切勿**在生成中趋同于常见选择（例如 Space Grotesk）。

**重要**：使实现复杂度与美学愿景匹配。极繁主义设计需要包含大量动画和效果的复杂代码。极简或精致设计则需要克制、精准，以及对间距、排版和微妙细节的精心关注。优雅源于对愿景的出色执行。

谨记：Claude 能够完成非凡的创意工作。不要拘束，展示当跳出框架思考并全心投入独特愿景时，真正能创造出什么。
```

**优势所在**：具备创意能力且边界清晰，内嵌版权保护，为非专业人士提供技术脚手架，设定质量标准。

-----

## 常见问题

### 如何编写能真正触发的描述？

聚焦于能力和场景，而非通用关键词。包含动作动词、具体文件类型和明确用例。与其写“文档处理技能”，不如写“从 PDF 中提取表格并转换为 CSV 格式，用于数据分析工作流”。

### Claude 如何决定调用哪些技能？

Claude 使用语义理解将你的请求与技能描述进行匹配。这不是关键词匹配——Claude 判断的是上下文相关性。若多个技能处理你请求的不同方面，它们可同时激活。

### 我的描述应有多细粒度？

以单一用途技能为目标。“博客文章的 SEO 优化”足够聚焦以提供具体指令，又足够宽泛以支持复用。太宽泛：“内容营销助手”。太狭窄：“添加 meta 描述”。

### 如何在组织内共享技能？

无论团队规模大小，建议创建一个包含技能规范的共享文档仓库。

- **小团队**：使用包含名称、描述、指令和版本信息的模板格式。
- **中大型团队**：建立技能治理流程：
  - 为每个领域（财务、法律、营销）指定技能负责人
  - 以中央 Wiki 或共享驱动器作为技能库
  - 为每个技能包含使用示例和常见故障排除
  - 对技能进行版本控制，并在变更日志中记录更新
  - 每季度安排审查，更新或淘汰过时技能

**所有团队规模的最佳实践**：

- 为每个技能记录业务目的
- 指定明确的维护和更新负责人
- 创建入职材料，向新成员展示如何实施共享技能
- 跟踪哪些技能创造最大价值，以优先安排维护工作
- 使用一致的命名规范，便于查找技能

企业客户可联系 Anthropic 客户成功团队，探索额外的部署选项和治理框架。

### 如何调试技能？

分别测试触发和执行。若技能未激活，拓宽描述并添加用例。若结果不一致，增强指令的具体性并加入验证步骤。创建一个测试用例库，覆盖常规使用、边缘情况和范围外请求。

### 如何在组织内共享技能？

在 **Claude.ai** 中，技能目前为**每个用户个人专属**，但组织级管理和共享功能即将推出。在此期间，无论团队规模大小，建议创建一个包含技能规范的共享文档仓库。此举既为迎接即将推出的功能做准备，也助你建立良好的治理实践。

-----

## 开始使用

准备好用技能构建了吗？以下是入门方式：

- **Claude.ai 用户**：
  - 在 设置 → 功能 中启用技能
  - 在 claude.ai/projects 创建你的首个项目
  - 尝试将项目知识与技能结合，用于下一项分析任务
- **API 开发者**：
  - 在文档中探索 Skills 端点
  - 查看我们的技能食谱（skills cookbook）
- **Claude Code 用户**：
  - 通过插件市场安装技能
  - 查看我们的技能食谱（skills cookbook）

很显然，写这种Skills是非常繁琐的，可以结合现在的部分AI工具自动生成，比如在代码领域就有部分IDE已经支持根据代码库生成详细提示词，可以减少很多的工作量。
